<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>

  <meta http-equiv="origin-trial"
    content="Ahfj+MLeL6bh+LNmpnSdepftxoDHHwjUG2KWZ4jjCb1WoZxtBlzF3cDHuJNVqnhr3HXJwQ+kLaw57NO15S0mRwwAAABkeyJvcmlnaW4iOiJodHRwczovL2ltbWVyc2l2ZS13ZWIuZ2l0aHViLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUlBsYW5lRGV0ZWN0aW9uIiwiZXhwaXJ5IjoxNjI5ODQ5NTk5fQ==">

  <title>AR Mesh Detection</title>

  <link href='../css/common.css' rel='stylesheet'>
  </link>
  <script
    type="modele"
    src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
    crossorigin="anonymous"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1/dist/peerjs.min.js"></script>

</head>

<body>
  <canvas id="mediapipe-canvas"></canvas>
  <video id="segmentVideo" autoplay muted style="display: none;"></video>
  <header>
    <details open>
      <summary>AR Mesh Detection</summary>
      This sample demonstrates using the
      <a href="https://immersive-web.github.io/real-world-meshing/">>Mesh Detection feature</a>
      including an implementation of synchronous hit test in JavaScript
      that leverages obtained mesh data to position objects.
      <p>
        <input id="showMeshTriangles" type="checkbox" checked>
        <label for="showMeshTriangles">Mesh triangles visible</label><br />

        <input id="useDomOverlay" type="checkbox" checked>
        <label for="useDomOverlay">Enable DOM Overlay</label><br />

        <a class="back" href="./index.html">Back</a>
      </p>
    </details>
  </header>
  <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
  <script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/",
          "three-mesh-ui": "https://unpkg.com/three-mesh-ui@6.5.4/build/three-mesh-ui.module.js"
				}
			}
		</script>

  <script type="module">
    // Code adapted from THREE.js' WebXR hit test sample.
    // THREE.js is covered by MIT license which can be found at:
    // https://github.com/mrdoob/THREE.js/blob/master/LICENSE

    // The code also links to a .png file from ARCore Android SDK.
    // It is covered by Apache 2.0 license which can be found at:
    // https://github.com/google-ar/arcore-android-sdk/blob/c684bbda37e44099c273c3e5274fae6fccee293c/LICENSE

    import * as THREE from 'three';
    import * as ThreeMeshUI from "three-mesh-ui";
    //import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
    import { BoxLineGeometry } from 'three/examples/jsm/geometries/BoxLineGeometry.js';
    //import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    //import VRControl from './utils/VRControl.js';
    import { XRControllerModelFactory } from './webxr-hands-examples-main/jsm/webxr/XRControllerModelFactory.js';
    import {createText} from 'three/examples/jsm/webxr/Text2D.js';
    import { WebXRButton } from '../js/util/webxr-button.js';
    //import { hitTest, filterHitTestResults } from '../js/hit-test.js';
    import {
      PoseLandmarker,
      FaceLandmarker,
      DrawingUtils,
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision";    
    import { OculusHandModel } from './webxr-hands-examples-main/js/OculusHandModel.js'; 
    import { GameObject, Component, GameObjectManager } from './webxr-hands-examples-main/js/EntityComponentSystem.js';
    import { PhysicalButtonComponent } from './webxr-hands-examples-main/js/PhysicalButtonComponent.js';

    const showMeshTriangles = document.getElementById('showMeshTriangles');

    const allMeshOrigins = [];

    function updateState() {
      const createMeshMaterial = (params) =>
        new THREE.MeshBasicMaterial(Object.assign(params, {
          opacity: 0.15,
          transparent: true,
          //depthTest: true
        }));

      meshMaterials.splice(0, meshMaterials.length)
      if (showMeshTriangles.checked) {
        // preallocate colors for various meshes  
        meshMaterials.push(createMeshMaterial({ color: 0xff0000 }));
        meshMaterials.push(createMeshMaterial({ color: 0x00ff00 }));
        meshMaterials.push(createMeshMaterial({ color: 0x0000ff }));
        meshMaterials.push(createMeshMaterial({ color: 0xffff00 }));
        meshMaterials.push(createMeshMaterial({ color: 0x00ffff }));
        meshMaterials.push(createMeshMaterial({ color: 0xff00ff }));
      } else {
        // if the mesh is not visible, set the blending so the mesh "punches"
        // out vr content behind it. This will occlude the VR scene with the 
        // real world.
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.FrontSide });
        material.blending = THREE.CustomBlending;
        material.blendEquation = THREE.AddEquation;
        material.blendSrc = THREE.ZeroFactor;
        material.blendDst = THREE.ZeroFactor;
        material.depthWrite = false;
        //material.depthTest = true;
        meshMaterials.push(material);
      }
    }

    showMeshTriangles.addEventListener('input', element => updateState());

    // Suppress XR events for interactions with the DOM overlay
    document.querySelector('header').addEventListener('beforexrselect', (ev) => {
      console.log(ev.type);
      ev.preventDefault();
    });


    let container;
    //let camera, scene, renderer, vrControl;
    let camera, scene, renderer;
    let meshContainer, meshes, currentMesh;
    const objsToTest = [];
    let selectState = false;
    const raycaster = new THREE.Raycaster();


    let xrButton = null;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    let hand1, hand2;
    let handModel1, handModel2;
    let consoleMesh, torusKnot, instructionText, exitText;
    let xrSession;
    let gameObjectManager;
    let positionCalibrated = false;
    let buttonPressSound, buttonReleaseSound;

    const tempMatrix = new THREE.Matrix4();

    // let reticle;
    // hitResult will be set when reticle is visible:
    let hitResult;

    let plane;

    let mediapipeCanvas;
    let ctx;
    let video;
    let drawingUtils;

    const peer = new Peer();
    let conn;
    let jsonData;
    let videoWidth;
    let videoHeight;
    let textPlanes = [];

    // UI
    //
    const uiContainer = new THREE.Group();
    let userTexts = [];
    let userText1;
    let userText2;
    let userText3;
    const uiGroup = new THREE.Group();
    uiGroup.renderOrder = 2;
    let currentYOffset = 0;
    let textPanelContents = [];

    // for Testing:
    // textPanelContents[0] = "1. The image shows a tortilla placed on a cutting board.";
    // //push
    // textPanelContents.push("2. The image shows a jar of nut butter.");
    function makeButtonMesh(x, y, z, color) {
      const geometry = new THREE.BoxGeometry(x, y, z);
      const material = new THREE.MeshPhongMaterial({ color: color });
      const buttonMesh = new THREE.Mesh(geometry, material);
      return buttonMesh;
    }
    
    function setupPeerConnection(){
      peer.on("open", (id) => {
        console.log(id);
        conn = peer.connect("4d7a1");
        conn.on("open", () => {
          console.log("Start receiving data");
          conn.on("data", (data) => {
            try {
              // console.log("receiving data");
              jsonData = JSON.parse(data);
              window.jsonData = jsonData;
              //drawData(jsonData);
              //console.log(jsonData);
              videoWidth = jsonData.streamWidth;
              videoHeight = jsonData.streamHeight;

              const newHints = jsonData.hintsHistory.map(hint => hint.hint);
              if (hintsHaveChanged(newHints)) {
                  // Only reset and repopulate textPanelContents if the hints have changed
                  textPanelContents = []; // Reset the contents
                  jsonData.hintsHistory.forEach(hint => {
                    textPanelContents.push(hint.hint);
                  });

                  clearGroup(uiGroup); // Clear existing UI elements
                  makeTextPanel(); // Re-create text panels with updated hints
              }
              
            } catch (e) {
              console.error("Error parsing received JSON:", e);
            }
          });
        });

        peer.on("call", (call) => {
          call.answer();
          call.on("stream", (stream) => {
            console.log("stream");
            video = document.getElementById("segmentVideo");
            video.srcObject = stream;
            video.play();
          });
        });
      });
    }

    // // 绘制数据
    // function drawData(result) {
    //     ctx.clearRect(0, 0, mediapipeCanvas.width, mediapipeCanvas.height);
    //     if (result.objectDetector) drawObject(result);
    //     updatePlaneMaterial(mediapipeCanvas); // 更新 Three.js 平面的材质
        
    //     // Assuming hints are in result.hintsHistory
    //     let startY = 20; // Start 20 pixels from the top of the canvas
    //     const hintHeight = 20; // Assuming each hint needs 20 pixels of height
    //     for (let hint of result.hintsHistory) {
    //         // Draw the hint text at the current Y position
    //         ctx.fillStyle = "#000000";
    //         ctx.font = "12px Arial";
    //         ctx.fillText(hint.hint, 10, startY); // Draw hint at x=10, y=startY
            
    //         startY += hintHeight; // Move startY down for the next hint
    //     }
    // }

    // 更新 Three.js 平面的材质
    function updatePlaneMaterial(textureCanvas) {
        const texture = new THREE.CanvasTexture(textureCanvas);
        texture.needsUpdate = true;
        plane.material.map = texture;
        plane.material.needsUpdate = true;
    }

    // 处理 MediaPipe 检测到的对象
    //-----the same------
    // function drawObject(result) {
    //   for (let detection of result.objectDetector.detections) {
    //     const name = detection.categories[0].categoryName;
    //     const score = Math.round(
    //       parseFloat(detection.categories[0].score) * 100
    //     );
    //     const bbox = detection.boundingBox;
    //     let x = bbox.originX;
    //     let y = bbox.originY;
    //     let width = bbox.width;
    //     let height = bbox.height;
    //     let centerX = x + width / 2;
    //     let centerY = y + height / 2;
    //     //console.log(name, score, x, y, width, height);

    //     ctx.strokeStyle = "#fff";
    //     ctx.fillStyle = "rgba(255, 255, 0, 0.25)";
    //     ctx.lineWidth = 1;
    //     ctx.fillRect(x, y, width, height);
    //     ctx.strokeRect(x, y, width, height);

    //     ctx.fillRect(centerX - 2, centerY - 2, 4, 4);
    //     ctx.strokeRect(centerX - 2, centerY - 2, 4, 4);

    //     ctx.fillStyle = "#007f8b";
    //     ctx.font = "12px Arial";
    //     ctx.fillText(`${name} - ${score}%`, x, y - 10);
    //   }

    //   for (let hint of result.hintsHistory) {
    //     ctx.fillStyle = "#000000";
    //     ctx.font = "12px Arial";
    //     // make the hint at the center of screen
    //     ctx.fillText(hint.hint, mediapipeCanvas.width / 2, mediapipeCanvas.height / 2);
    //     // console.log(hint.hint, hint.row, hint.column);
    //     console.log(hint.hint);
    //   }
    // }

    const meshMaterials = [];
    const wireframeMaterial = new THREE.MeshBasicMaterial({ wireframe: true });
    const baseOriginGroup = new THREE.Group();

    init();
    setupPeerConnection();

    function setTextPanel(textPanelContent){

      // set background
      const conBlank = new ThreeMeshUI.Block( {
        justifyContent: 'start',  
        contentDirection: 'column',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07*0.0789*1.2,
        //bestFit: 'auto',
        padding: 0.10*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 1,
          borderColor: new THREE.Color( 0x0D87E0 ),
        backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.75,
        borderRadius: 0.11*0.0789*1.2,
        width: 1.9*0.0789*1.2,
        height: 0.5*0.05*2*0.8,
      } );
      conBlank.position.set(0, -0.03 + currentYOffset, 0);
      uiGroup.add(conBlank);

      // set text
      const conText = new ThreeMeshUI.Block( {
      width: 1.9*0.0789*1.2,
      height: 0.5*0.0789*1.2,
      padding: 0.10*0.0789*1.2,
      justifyContent: "center",
      textAlign: "left",
      bestFit: 'grow',

      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x0D87E0 ),

      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0,

      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );

      conText.position.set(0, -0.03 + currentYOffset, -0.01);
      conText.add(
      new ThreeMeshUI.Text({
        content: textPanelContent,
        fontSize: 0.05*0.2*0.8,
      })
      );
      uiGroup.add(conText);

      currentYOffset -= 0.048;
    }

    function makeTextPanel() {
      currentYOffset = 0; // Reset the offset for each update

      // set background
      const containerBlank = new ThreeMeshUI.Block( {
        justifyContent: 'start',  
        contentDirection: 'column',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07*0.0789*1.2,
        //bestFit: 'auto',
        padding: 0.10*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 1,
          borderColor: new THREE.Color( 0x0D87E0 ),
        backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.75,
        borderRadius: 0.11*0.0789*1.2,
        width: 1.9*0.0789*1.2,
        height: 0.5*0.05*4*1.2,
      } );
      containerBlank.position.set(0, 0.25*0.0789*5-0.03, 0);
      uiGroup.add(containerBlank);

      // set text
      const containerText = new ThreeMeshUI.Block( {
        width: 1.9*0.0789*1.2,
      height: 0.5*0.0789*1.2,
      padding: 0.10*0.0789*1.2,
      justifyContent: "center",
      textAlign: "left",
      bestFit: 'grow',

      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x0D87E0 ),

      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0,

      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      containerText.position.set(0, 0.35*0.0789*2.7+0.04-0.03, -0.01);
      containerText.add(
        new ThreeMeshUI.Text({
          content: "Step 2: Use a butter knife to scoop nut butter from the jar. Spread nut butter onto tortilla, leaving 1/2-inch uncovered at the edges.",
          fontSize: 0.05*0.0789*2,
        })
      );
      uiGroup.add(containerText);

      // for (let i=0; i<textPanelContents.length; i++){
      // setTextPanel(textPanelContents[i]);
      // //set an offset on Y axis for each text panel
      // //textPanelContents[i].position.set(0, 0.5, 0);
      // }

      textPanelContents.forEach(content => {
        setTextPanel(content);
      });

    }

    function clearGroup(group) {
      while(group.children.length > 0){ 
        const child = group.children[0];
        group.remove(child); 
        if(child.geometry) child.geometry.dispose();
        if(child.material) child.material.dispose();
        if(child.texture) child.texture.dispose();
      }
    }

    function hintsHaveChanged(newHints) {
        if (newHints.length !== textPanelContents.length) return true;
        for (let i = 0; i < newHints.length; i++) {
            if (newHints[i] !== textPanelContents[i]) return true;
        }
        return false;
    }

    function makeUI() {
      //uiContainer.renderOrder = 2;
      scene.add(uiContainer);

      const textPanel = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.15,
        //padding: 0.05,
        justifyContent: "center",
        textAlign: "left",
        fontFamily: "./fonts/Roboto-msdf.json",
        fontTexture: "./fonts/Roboto-msdf.png"
      });

      textPanel.position.set(0, -0.15, 0);

      uiContainer.add(textPanel);

      const title = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.05,
        justifyContent: "center",
        fontSize: 0.006,
        backgroundOpacity: 0,
      }).add(
        new ThreeMeshUI.Text({ content: "Type some text on the keyboard" })
      );
      
      for (let i = 0; i < 3; i++) {
        userTexts.push(new ThreeMeshUI.Text({ content: "The image shows a tortilla placed on a cutting board, which means you have completed step 1.\n" }));
      }
      
      const textField = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.2,
        fontSize: 0.006,
        padding: 0.012,
        backgroundOpacity: 0,
        //interLine: 0.05,
        //bestFit: 'shrink'
      })

      for (let i = 0; i < userTexts.length; i++) {
        textField.add(userTexts[i]);
      }

      textPanel.add(title, textField);
    }

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      // set up three.js boilerplate
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setFoveation(0);
      renderer.autoClear = false;
      container.appendChild(renderer.domElement);

      xrButton = new WebXRButton({
        onRequestSession: onRequestSession,
        onEndSession: onEndSession,
        textEnterXRTitle: "START AR",
        textXRNotFoundTitle: "AR NOT FOUND",
        textExitXRTitle: "EXIT AR",
      });

      document.querySelector('header').appendChild(xrButton.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then((supported) => {
            xrButton.enabled = supported;
          });
      }

      // // add controllers to the scene
      // controller1 = renderer.xr.getController(0);
      // controller1.addEventListener('selectstart', onSelectStart);
      // controller1.addEventListener('selectend', onSelectEnd);
      // controller1.addEventListener('connected', function (event) {
      //   this.add(buildController(event.data));
      // });

      // controller1.addEventListener('disconnected', function () {
      //   this.remove(this.children[0]);
      // });

      // scene.add(controller1);

      // controller2 = renderer.xr.getController(1);
      // controller2.addEventListener('selectstart', onSelectStart);
      // controller2.addEventListener('selectend', onSelectEnd);
      // controller2.addEventListener('connected', function (event) {
      //   this.add(buildController(event.data));
      // });

      // scene.add(controller2);

      // controllers

      controller1 = renderer.xr.getController(0);
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      scene.add(controller2);

      const controllerModelFactory = new XRControllerModelFactory();

      // Hand 1
      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      hand1 = renderer.xr.getHand(0);
      handModel1 = new OculusHandModel(hand1);
      hand1.add(handModel1);

      scene.add(hand1);

      // Hand 2
      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      hand2 = renderer.xr.getHand(1);
      handModel2 = new OculusHandModel(hand2);
      hand2.add(handModel2);
      scene.add(hand2);

      // controller2.addEventListener('disconnected', function () {
      //   this.remove(this.children[0]);
      // });
      //scene.add(controller2);

      ////////////////
      // Controllers
      ////////////////

      // vrControl = VRControl( renderer, camera, scene );

      // scene.add( vrControl.controllerGrips[ 0 ], vrControl.controllers[ 0 ] );

      // vrControl.controllers[ 0 ].addEventListener( 'selectstart', () => {

      //   selectState = true;

      // } );
      // vrControl.controllers[ 0 ].addEventListener( 'selectend', () => {

      //   selectState = false;

      // } );

      gameObjectManager = new GameObjectManager();

      // buttons
      let buttonClearAction = function () {
        buttonReleaseSound.play();
      }
      const consoleGeometry = new THREE.BoxGeometry(0.5, 0.12, 0.15);
      const consoleMaterial = new THREE.MeshPhongMaterial({ color: 0x595959 });
      consoleMesh = new THREE.Mesh(consoleGeometry, consoleMaterial);
      consoleMesh.position.set(0, 1, -0.3);
      scene.add(consoleMesh);

      let orangeButtonObject = gameObjectManager.createGameObject(consoleMesh, "orange-button");
      let orangeButton = makeButtonMesh(0.08, 0.1, 0.08, 0xffd3b5);
      orangeButtonObject.transform.add(orangeButton);
      orangeButtonObject.transform.position.set(-0.15, 0.04, 0);
      let orangeButtonPressAction = function () {
        buttonPressSound.play();
        torusKnot.material.color.setHex(0xffd3b5);
      }
      orangeButtonObject.addComponent(PhysicalButtonComponent, [handModel1, handModel2], orangeButtonPressAction, buttonClearAction);

      let pinkButtonObject = gameObjectManager.createGameObject(consoleMesh, "pink-button");
      let pinkButton = makeButtonMesh(0.08, 0.1, 0.08, 0xe84a5f);
      pinkButtonObject.transform.add(pinkButton);
      pinkButtonObject.transform.position.set(-0.05, 0.04, 0);
      let pinkButtonPressAction = function () {
        buttonPressSound.play();
        torusKnot.material.color.setHex(0xe84a5f);
      }
      pinkButtonObject.addComponent(PhysicalButtonComponent, [handModel1, handModel2], pinkButtonPressAction, buttonClearAction);

      let resetButtonObject = gameObjectManager.createGameObject(consoleMesh, "exit-button");
      let resetButton = makeButtonMesh(0.08, 0.1, 0.08, 0x355c7d);
      let resetText = createText("reset", 0.03);
      resetButton.add(resetText);
      resetText.rotation.x = - Math.PI / 2;
      resetText.position.set(0, 0.051, 0);
      resetButtonObject.transform.add(resetButton);
      resetButtonObject.transform.position.set(0.05, 0.04, 0);
      let resetButtonPressAction = function () {
        buttonPressSound.play();
        torusKnot.material.color.setHex(0xffffff);
      }
      resetButtonObject.addComponent(PhysicalButtonComponent, [handModel1, handModel2], resetButtonPressAction, buttonClearAction);

      let exitButtonObject = gameObjectManager.createGameObject(consoleMesh, "exit-button");
      let exitButton = makeButtonMesh(0.08, 0.1, 0.08, 0xff0000);
      let exitText = createText("exit", 0.03);
      exitButton.add(exitText);
      exitText.rotation.x = - Math.PI / 2;
      exitText.position.set(0, 0.051, 0);
      exitButtonObject.transform.add(exitButton);
      exitButtonObject.transform.position.set(0.15, 0.04, 0);
      let exitButtonPressAction = function () {
        buttonPressSound.play();
        exitText.visible = true;
        setTimeout(function () { exitText.visible = false; renderer.xr.getSession().end(); }, 2000);
      }
      exitButtonObject.addComponent(PhysicalButtonComponent, [handModel1, handModel2], exitButtonPressAction, buttonClearAction);

      const tkGeometry = new THREE.TorusKnotGeometry(0.5, 0.2, 200, 32);
      const tkMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
      tkMaterial.metalness = 0.8;
      torusKnot = new THREE.Mesh(tkGeometry, tkMaterial);
      torusKnot.position.set(0, 1, -5);
      scene.add(torusKnot);

      instructionText = createText("This is a WebXR Hands demo, please explore with hands.", 0.04);
      instructionText.position.set(0, 1.6, -0.6);
      scene.add(instructionText);

      exitText = createText("Exiting session...", 0.04);
      exitText.position.set(0, 1.5, -0.6);
      exitText.visible = false;
      scene.add(exitText);

      const planeGeometry = new THREE.PlaneGeometry(3.22, 2.48);
      const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      plane = new THREE.Mesh(planeGeometry, planeMaterial);
      scene.add(plane);

      ////////////////////
      // Primitive Meshes
      ////////////////////

      meshContainer = new THREE.Group();
      meshContainer.position.set( 0, 1, -1.9 );
      scene.add( meshContainer );

      //

      const sphere = new THREE.Mesh(
        new THREE.IcosahedronBufferGeometry( 0.3, 1 ),
        new THREE.MeshStandardMaterial( { color: 0x3de364, flatShading: true } )
      );

      const box = new THREE.Mesh(
        new THREE.BoxBufferGeometry( 0.45, 0.45, 0.45 ),
        new THREE.MeshStandardMaterial( { color: 0x643de3, flatShading: true } )
      );

      const cone = new THREE.Mesh(
        new THREE.ConeBufferGeometry( 0.28, 0.5, 10 ),
        new THREE.MeshStandardMaterial( { color: 0xe33d4e, flatShading: true } )
      );

      //

      sphere.visible = box.visible = cone.visible = false;

      meshContainer.add( sphere, box, cone );

      meshes = [ sphere, box, cone ];
      currentMesh = 0;

      showMesh( currentMesh );

      //mediapipeCanvas = document.getElementById("mediapipe-canvas");
      //ctx = mediapipeCanvas.getContext("2d", { alpha: true });
      // drawingUtils = new DrawingUtils(ctx);
      // window.drawingUtils = drawingUtils;
      
      scene.add(uiGroup);
      //makeUI();
      // Update UI with new hints
      clearGroup(uiGroup); // Clear existing UI elements
      makeTextPanel();
      makePanel();

      updateState();

      window.addEventListener('resize', onWindowResize);
    }

    function buildController(data) {

      let geometry, material;

      switch (data.targetRayMode) {
        case 'tracked-pointer':
          geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

          material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

          return new THREE.Line(geometry, material);
        case 'gaze':
          geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
          material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
          return new THREE.Mesh(geometry, material);
      }
    }

    let pointer = undefined;

    function onSelectStart(event) {
      selectState = true;
      pointer = event.target;
    }
    function onSelectEnd(event) {
      selectState = false;
      pointer = undefined;
    }

    function draw() { // the original raycasting function
      if (pointer === undefined) {
        return;
      }


      let yOffset = 0; 
      textPlanes.forEach(textPlane => {
        scene.remove(textPlane);
        if (textPlane.geometry) textPlane.geometry.dispose();
        if (textPlane.material) textPlane.material.dispose();
      });
      textPlanes = [];

          
      // Process hints in reverse order to have the last one as the baseline
      jsonData.hintsHistory.slice().reverse().forEach((hint, index) => {
        const name = hint.hint;
        let a = 0; // 'a' remains constant to keep hints aligned vertically
        let b = 0; // 'b' is constant because we're manually adjusting the vertical offset

        const textPlane = createText(name, 0.0125);
        textPlane.matrixAutoUpdate = true;
        textPlane.visible = false;
        scene.add(textPlane);
        const raycaster = new THREE.Raycaster();

        raycaster.setFromCamera(new THREE.Vector2(a, b), camera);

        allMeshes.forEach((meshContext, mesh) => {
          const intersections = raycaster.intersectObject(meshContext.mesh);

          if (intersections.length > 0) {
            textPlane.visible = true;
            // Position the baseline hint, then adjust yOffset upwards for each subsequent hint
            textPlane.position.copy(intersections[0].point).add(new THREE.Vector3(0, yOffset, 0));
            textPlane.material.depthTest = false;
            textPlane.material.needsUpdate = true;
            textPlanes.push(textPlane);

            // Increment yOffset to move the next hint upwards
            yOffset += 0.02; // Adjust this value as needed for your spacing
          }
        });
      });
    }

    function onRequestSession() {
      let sessionInit = {
        requiredFeatures: ['hit-test', 'mesh-detection'],
        optionalFeatures: [],
      };
      if (useDomOverlay.checked) {
        sessionInit.optionalFeatures.push('dom-overlay');
        sessionInit.domOverlay = { root: document.body };
      }
      navigator.xr.requestSession('immersive-ar', sessionInit).then((session) => {
        session.mode = 'immersive-ar';
        xrButton.setSession(session);
        onSessionStarted(session);
      });
    }

    function onSessionStarted(session) {
      useDomOverlay.disabled = true;
      session.addEventListener('end', onSessionEnded);

      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);

      renderer.setAnimationLoop(render);
    }

    function onEndSession(session) {
      session.end();
    }

    function onSessionEnded(event) {
      useDomOverlay.disabled = false;
      xrButton.setSession(null);

      renderer.setAnimationLoop(null);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(0, 0.1, 0);

    function createGeometry(vertices, indices) {
      const geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

      return geometry;
    }

    let meshId = 1;
    let allMeshes = new Map();
    // Iterate over the meshes array and compare to our internal state
    // This is the code that keeps track of the mesh state and adds them to the scene.
    function processMeshes(timestamp, frame) {
      const referenceSpace = renderer.xr.getReferenceSpace();

      if (frame.detectedMeshes) {
        allMeshes.forEach((meshContext, mesh) => {
          // if a previous mesh is no longer reported
          if (!frame.detectedMeshes.has(mesh)) {
            // mesh was removed
            allMeshes.delete(mesh);
            console.debug("Mesh no longer tracked, id=" + meshContext.id);

            scene.remove(meshContext.mesh);
            scene.remove(meshContext.wireframe);
          }
        });

        // compare all incoming meshes with our internal state
        frame.detectedMeshes.forEach(mesh => {
          const meshPose = frame.getPose(mesh.meshSpace, referenceSpace);
          let meshMesh;
          let wireframeMesh;

          // this is a mesh we've seen before
          if (allMeshes.has(mesh)) {
            // may have been updated:
            const meshContext = allMeshes.get(mesh);
            meshMesh = meshContext.mesh;
            wireframeMesh = meshContext.wireframe;

            if (meshContext.timestamp < mesh.lastChangedTime) {
              // the mesh was updated!
              meshContext.timestamp = mesh.lastChangedTime;

              const geometry = createGeometry(mesh.vertices, mesh.indices);
              meshContext.mesh.geometry.dispose();
              meshContext.mesh.geometry = geometry;
              meshContext.wireframe.geometry.dispose();
              meshContext.wireframe.geometry = geometry;
            }
          } else {
            // new mesh

            // Create geometry:
            const geometry = createGeometry(mesh.vertices, mesh.indices);

            //wireframeMaterial.depthTest = true;
            wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
            wireframeMesh.matrixAutoUpdate = false;
            scene.add(wireframeMesh);

            meshMesh = new THREE.Mesh(geometry,
              meshMaterials[meshId % meshMaterials.length]
            );
            //meshMesh.material.depthTest = true;
            meshMesh.matrixAutoUpdate = false;
            scene.add(meshMesh);
            const originGroup = baseOriginGroup.clone();
            originGroup.visible = false;

            meshMesh.add(originGroup);
            allMeshOrigins.push(originGroup);

            const meshContext = {
              id: meshId,
              timestamp: mesh.lastChangedTime,
              mesh: meshMesh,
              wireframe: wireframeMesh,
              origin: originGroup,
            };

            allMeshes.set(mesh, meshContext);
            console.debug("New mesh detected, id=" + meshId);
            meshId++;
          }

          if (meshPose) {
            meshMesh.visible = true;
            meshMesh.matrix.fromArray(meshPose.transform.matrix);
            wireframeMesh.visible = showMeshTriangles.checked;
            wireframeMesh.matrix.fromArray(meshPose.transform.matrix);
          } else {
            meshMesh.visible = false;
            wireframeMesh.visible = false;
          }
        });
      }
    }

    function showMesh( id ) {
      meshes.forEach( ( mesh, i ) => {
        mesh.visible = i === id ? true : false;
      } );
    }

    function makePanel() {
      // Create a panel with two buttons to switch between the three meshes
      // Container block, in which we put the two buttons.
      // We don't define width and height, it will be set automatically from the children's dimensions
      // Note that we set contentDirection: "row-reverse", in order to orient the buttons horizontally

      const container = new ThreeMeshUI.Block( {
        justifyContent: 'center',
        contentDirection: 'row-reverse',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07,
        padding: 0.02,
        borderRadius: 0.11
      } );

      container.position.set( 0, 0.6, -1.2 );
      container.rotation.x = -0.55;
      scene.add( container );

      // BUTTONS

      // We start by creating objects containing options that we will use with the two buttons,
      // in order to write less code.

      const buttonOptions = {
        width: 0.4,
        height: 0.15,
        justifyContent: 'center',
        offset: 0.05,
        margin: 0.02,
        borderRadius: 0.075
      };

      // Options for component.setupState().
      // It must contain a 'state' parameter, which you will refer to with component.setState( 'name-of-the-state' ).

      const hoveredStateAttributes = {
        state: 'hovered',
        attributes: {
          offset: 0.035,
          backgroundColor: new THREE.Color( 0x999999 ),
          backgroundOpacity: 1,
          fontColor: new THREE.Color( 0xffffff )
        },
      };

      const idleStateAttributes = {
        state: 'idle',
        attributes: {
          offset: 0.035,
          backgroundColor: new THREE.Color( 0x666666 ),
          backgroundOpacity: 0.3,
          fontColor: new THREE.Color( 0xffffff )
        },
      };

      // Buttons creation, with the options objects passed in parameters.

      const buttonNext = new ThreeMeshUI.Block( buttonOptions );
      const buttonPrevious = new ThreeMeshUI.Block( buttonOptions );

      // Add text to buttons

      buttonNext.add(
        new ThreeMeshUI.Text( { content: 'next' } )
      );

      buttonPrevious.add(
        new ThreeMeshUI.Text( { content: 'previous' } )
      );

      // Create states for the buttons.
      // In the loop, we will call component.setState( 'state-name' ) when mouse hover or click

      const selectedAttributes = {
        offset: 0.02,
        backgroundColor: new THREE.Color( 0x777777 ),
        fontColor: new THREE.Color( 0x222222 )
      };

      buttonNext.setupState( {
        state: 'selected',
        attributes: selectedAttributes,
        onSet: () => {

          currentMesh = ( currentMesh + 1 ) % 3;
          showMesh( currentMesh );

        }
      } );
      buttonNext.setupState( hoveredStateAttributes );
      buttonNext.setupState( idleStateAttributes );

      //

      buttonPrevious.setupState( {
        state: 'selected',
        attributes: selectedAttributes,
        onSet: () => {

          currentMesh -= 1;
          if ( currentMesh < 0 ) currentMesh = 2;
          showMesh( currentMesh );

        }
      } );
      buttonPrevious.setupState( hoveredStateAttributes );
      buttonPrevious.setupState( idleStateAttributes );

      //

      container.add( buttonNext, buttonPrevious );
      objsToTest.push( buttonNext, buttonPrevious );

    }

    // function updateButtons() {
    //   // Find closest intersecting object

    //   let intersect;

    //   if (renderer.xr.isPresenting) {
    //     vrControl.setFromController(0, raycaster.ray);

    //     intersect = raycast();

    //     // Position the little white dot at the end of the controller pointing ray
    //     if (intersect) vrControl.setPointerAt(0, intersect.point);
    //   } else if (mouse.x !== null && mouse.y !== null) {
    //     raycaster.setFromCamera(mouse, camera);

    //     intersect = raycast();
    //   }

    //   // Update targeted button state (if any)

    //   if (intersect && intersect.object.isUI) {
    //     if (selectState) {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       intersect.object.setState("selected");
    //     } else {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       intersect.object.setState("hovered");
    //     }
    //   }

    //   // Update non-targeted buttons state

    //   objsToTest.forEach((obj) => {
    //     if ((!intersect || obj !== intersect.object) && obj.isUI) {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       obj.setState("idle");
    //     }
    //   });
    // }

    //

    function raycast() {
      return objsToTest.reduce((closestIntersection, obj) => {
        const intersection = raycaster.intersectObject(obj, true);

        if (!intersection[0]) return closestIntersection;

        if (
          !closestIntersection ||
          intersection[0].distance < closestIntersection.distance
        ) {
          intersection[0].object = obj;

          return intersection[0];
        }

        return closestIntersection;
      }, null);
    }

    
    function render(timestamp, frame) {
      gameObjectManager.update();
      torusKnot.rotation.x += 0.005;
      torusKnot.rotation.y += 0.005;
      instructionText.visible = controllerGrip1.visible || controllerGrip2.visible;

      if (frame) {
        processMeshes(timestamp, frame);
        //draw();

        // Update text planes to face the camera but keep them horizontally level
        textPlanes.forEach(textPlane => {
          // Copy the camera's position to a temporary vector
          let tempPosition = new THREE.Vector3();
          camera.getWorldPosition(tempPosition);

          // Ignore the Y component of the camera and text plane positions for the lookAt calculation
          //tempPosition.y = textPlane.position.y;

          // Make the text plane face towards the camera's XZ projection
          textPlane.lookAt(tempPosition);
        });

        uiGroup.position.copy(camera.position);
        uiGroup.rotation.copy(camera.rotation);
        uiGroup.translateZ(-0.5);
        uiGroup.translateY(-0.1);
        uiGroup.translateX(-0.2);
        //rotate the uiGroup in the y axis 30 degrees
        uiGroup.rotateY(20 * Math.PI / 180);
        uiGroup.rotateX(-10 * Math.PI / 180);


        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        
        if (plane && camera) {
          plane.position.copy(camera.position);
          plane.rotation.copy(camera.rotation);

          plane.translateZ(-2);
        }

        plane.visible = false;

        ThreeMeshUI.update();

        renderer.render(scene, camera);

        // adjusting console position when user first go immersive
        if (renderer.xr.getSession() && !positionCalibrated) {
          let xrCamera = renderer.xr.getCamera(camera);
          consoleMesh.position.y = xrCamera.position.y - 0.4;
          consoleMesh.position.z = xrCamera.position.z - 0.3;
          positionCalibrated = true;

          const listener = new THREE.AudioListener();
          xrCamera.add(listener);

          // create a global audio source
          buttonPressSound = new THREE.Audio(listener);
          buttonReleaseSound = new THREE.Audio(listener);

          // load a sound and set it as the Audio object's buffer
          const audioLoader = new THREE.AudioLoader();
          audioLoader.load('./webxr-hands-examples-main/sounds/button-press.ogg', function (buffer) {
            buttonPressSound.setBuffer(buffer);
          });
          audioLoader.load('./webxr-hands-examples-main/sounds/button-release.ogg', function (buffer) {
            buttonReleaseSound.setBuffer(buffer);
          });
        }

        //updateButtons();
      }
    }

  </script>
</body>

</html>